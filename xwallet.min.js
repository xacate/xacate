!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("ethers"),require("core-js/modules/es.error.cause.js"),require("@walletconnect/ethereum-provider")):"function"==typeof define&&define.amd?define(["exports","ethers","core-js/modules/es.error.cause.js","@walletconnect/ethereum-provider"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Wxt={},e.ethers,null,e["@walletconnect/ethereum-provider"])}(this,(function(e,t,r,n){"use strict";function a(e){return a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a(e)}function i(e){var t=function(e,t){if("object"!==a(e)||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!==a(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"===a(t)?t:String(t)}function s(e,t,r){return(t=i(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const o=async e=>{const r=await t.ethers.resolveProperties(e);return r.reason?r.reason:r.info?r.info?.error?.message:r.error?r.error.message:e.toString()};class c{constructor(){}getRightChainId(){return 0}getRightChainName(){return"BSC"}getRightChainHost(){return""}getRightChainExplorer(){return""}getRightTokenName(){return"BNB"}getName(){return"baseWallet"}async getWalletName(){return Promise.resolve("")}getProvider(){return Promise.resolve(null)}isConnected(){return!1}async connectWallet(){return Promise.resolve(!1)}getDefaultAccount(){return Promise.resolve(null)}async disconnect(){return!0}getDisRequestType(){return!1}getChainId(){return 0}listenAccountChanged(e){}listenChainIdChanged(e){}}class l extends n.EthereumProvider{static async init(e){const t=new l;return await t.initialize(e),t}}const u=["personal_sign","eth_sendTransaction","eth_accounts","eth_requestAccounts","eth_call","eth_getBalance","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode"];e.XBaseWallet=class{constructor(){s(this,"_baseProvideMap",{}),s(this,"_providerMap",{}),this._baseProvideMap=this.initBaseProvider(),this._providerMap=this.initProvider()}createBaseProvider(e){return new t.ethers.JsonRpcProvider(e)}initBaseProvider(){return{}}initProvider(){return{}}initMethod(){}set currentName(e){sessionStorage.setItem("__WALLET_TYPE__",e)}get currentName(){return sessionStorage.getItem("__WALLET_TYPE__")||"base"}async getCurrentProvider(){const e=await(this._providerMap[this.currentName]?.getProvider());return e?new t.ethers.BrowserProvider(e):null}getCurrentBaseProvider(e){return this._baseProvideMap[e.toString()]}async getWalletName(){return await this.getWallet().getWalletName()}getWallet(){return this._providerMap[this.currentName]}async connectWallet(e){this.currentName=e;return this.getWallet().connectWallet()}async disconnect(){const e=this.getWallet();return sessionStorage.removeItem("__WALLET_TYPE__"),e.disconnect()}async getDefaultAccount(){return this.getWallet().getDefaultAccount()}async switchEthereumChain(e=""){return this.getWallet().switchEthereumChain(e)}async getCurrentChainId(){return this.getWallet().getCurrentChainId()}async signMessage(e=""){return new Promise((async(t,r)=>{let n=e;"object"==typeof e?n=JSON.stringify(e):"string"!=typeof e&&(n=e.toString());if(null===await this.getDefaultAccount())return null;let a=null;const i=await this.getCurrentProvider(),s=await i.getSigner();this.getWallet().getDisRequestType()&&(a=setTimeout((async()=>{const e=this.getWallet().getName();this.getWallet().disconnect&&await this.getWallet().disconnect();try{await this.connectWallet(e);const r=await s.signMessage(n);t(r)}catch(e){r(await o(e))}}),3e4));try{const e=await s.signMessage(n);a&&clearTimeout(a),t(e)}catch(e){a&&clearTimeout(a),r(await o(e))}}))}},e.XBaseWalletMethod=class{constructor(e){s(this,"_getProvider",(()=>null)),s(this,"_getBaseProvider",(()=>null)),this._walletClient=e,this._getProvider=e.getCurrentProvider.bind(e),this._getBaseProvider=e.getCurrentBaseProvider.bind(e)}getDefaultAccount(){return this._walletClient.getDefaultAccount()}getWallet(){return this._walletClient}getBaseContract(e=null,r=""){r=r||this.getRightChainId();const n=this._getBaseProvider(r);if(!e)return new t.Contract(this.getContractAddress(),this.getContractAbi(),n);const a=this.contractDataMap()[e];return a?new t.Contract(a.address,a.abi,n):null}async getContract(e=null){const r=await this._getProvider();if(r){const n=await r.getSigner();if(!e)return new t.Contract(this.getContractAddress(),this.getContractAbi(),n);const a=this.contractDataMap()[e];if(a)return new t.Contract(a.address,a.abi,n)}return null}async transcationGasResult(e,t=[],r=null){try{r?.setText("estimateGas...");const n=await e.estimateGas(...t),a=await e._contract.runner.provider.getFeeData(),i=e(...t,{gasLimit:n,gasPrice:a.gasPrice});return this.transcationResult(i,r)}catch(e){return[!1,await o(e)]}}transcationResult(e,t=null){return new Promise((async r=>{const n=setTimeout((()=>{r([!1,"Transaction Timeout"])}),3e4);try{t?.setText(`Please confirm in the wallet(${await this.getWallet().getWalletName()})`);const a=await e;clearTimeout(n),t?.setText("Please confirm in the block");const i=await a.wait();r([!0,JSON.stringify(i)])}catch(e){r([!1,await o(e)])}}))}},e.XBaseWalletType=c,e.XDefaultWalletType=class extends c{constructor(...e){super(...e),s(this,"_provider",null)}async getProvider(){return this._provider||(this._provider=new t.ethers.JsonRpcProvider(this.getRightChainHost())),Promise.resolve(this._provider)}},e.XMetaMaskType=class extends c{constructor(){super(),this._listenWalletStatus()}getChainsInfo(e){return{}}getName(){return"metamask plugin"}async getWalletName(){return Promise.resolve("MetaMask Plugins")}async getProvider(){const e=window&&window.ethereum;return Promise.resolve(e)}async connectWallet(){return await this.switchEthereumChain(this.getRightChainId()),await this._enable()}async getDefaultAccount(){const e=this;async function t(){const t=await e.getProvider();return t&&t.selectedAddress}return new Promise((async(e,r)=>{const n=await t();if(n)return void e(n);let a=null;const i=setTimeout((async function(){const r=await t();a&&clearInterval(a),clearTimeout(i),e(r)}),2e3);a=setInterval((async function(){const r=await t();r&&(clearTimeout(i),clearInterval(a),e(r))}),10)}))}async getCurrentChainId(){const e=await this.getProvider();let r=e&&e.chainId;return t.ethers.isHexString(r)&&(r=Number(r)),r}async switchEthereumChain(e){e=e||this.getRightChainId();const t=this;return new Promise((async(r,n)=>{try{const n=await this.getProvider();if(null==n)return;const a="0x"+Number(e).toString(16);await n.request({method:"wallet_switchEthereumChain",params:[{chainId:a}]}),status?r(!0):setTimeout((function(){t._enable().then(r)}),2e3)}catch(a){if(4902===a.code)try{const n=await t._addEthereumChainParameter(e);return n||r(n),void setTimeout((function(){t._enable().then(r)}),2e3)}catch(e){n(e)}r(!1)}}))}async _addEthereumChainParameter(e){try{e=e||this.getRightChainId();const t=await this.getProvider();if(null==t)return;const r=this.getChainsInfo(e);return await t.request({method:"wallet_addEthereumChain",params:[{chainId:"0x"+Number(r.chainId).toString(16),chainName:r.chainName,rpcUrls:[r.rpcUrl],blockExplorerUrls:r.explorer?[r.explorer]:null,nativeCurrency:{name:r.token||"ETH",symbol:r.token||"ETH",decimals:r.decimals||18}}]}),!0}catch(e){return!1}}disconnect(){return!0}async _listenWalletStatus(){const e=await this.getProvider();null!=e&&(e.on("accountsChanged",(e=>{this.listenAccountChanged(e)})),e.on("chainChanged",(e=>{this.listenChainIdChanged(e)})))}async _enable(){const e=await this.getProvider();if(null==e)return!1;try{return await e.request({method:"eth_requestAccounts"}),!0}catch(e){return!1}}},e.XWalletConnect=class extends c{projectId(){return"682100cca9668c9ff2f41c500b2a4465"}getRpc(){return{56:"https://bsc-dataseed.binance.org/",97:"https://data-seed-prebsc-1-s1.binance.org:8545/"}}async _createProvider(){try{const e=this.getRpc();e[this.getRightChainId()]=this.getRightChainHost();const t=await l.init({projectId:this.projectId(),chains:[this.getRightChainId()],optionalChains:Object.keys(e),rpcMap:e,qrModalOptions:{themeMode:"light"},showQrModal:!0,methods:u});return t.on("accountsChanged",(async e=>{this.listenAccountChanged(e)})),t.on("chainChanged",(e=>{this.listenChainIdChanged(e)})),t.on("disconnect",(async()=>{this.listenAccountChanged([]),this.listenChainIdChanged(0),this._provider=null})),t.on("message",(()=>{})),t.on("message",(e=>{})),t.on("session_event",(e=>{})),t.on("session_update",(e=>{})),t}catch(e){return localStorage.removeItem("wc@2:client:0.3//session"),this._createProvider()}}getName(){return"wallectConnect"}async getWalletName(){const e=await this.getProvider();if(!e.session)return"unknown wallet";const{peer:{metadata:{name:t}}}=e.session;return t}async getProvider(){return this._provider||(this._provider=await this._createProvider()),this._provider}async connectWallet(){const e=await this.getProvider();return e?new Promise((t=>{e.enable().then((async e=>{Array.isArray(e)&&e.length>0&&t(!0)})).catch((e=>{t(!1)}))})):Promise.resolve(!1)}async getDefaultAccount(){const e=await this.getProvider();return null!==e.session&&Array.isArray(e.accounts)&&e.accounts.length>0?e.accounts[0]:null}async getCurrentChainId(){return(await this.getProvider()).chainId.toString()}async switchEthereumChain(e){const t=await this.getProvider();if(e.toString()===t.chainId.toString())return!0;try{return await t.connect({chains:[e]}),!0}catch(e){return!1}}async disconnect(e){if(e)return window.location.reload(),!0;for(var t in await this.getProvider(),localStorage)-1!==t.indexOf("wc@2:")&&localStorage.removeItem(t);return localStorage.removeItem("wc@2:client:0.3//session"),this._provider=null,!0}listenAccountChanged(e){}listenChainIdChanged(e){}},e.isAddress=e=>t.ethers.isAddress(e),e.parseJsonRpc=o}));
